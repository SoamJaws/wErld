<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/SoamJaws/wErld/.eunit/public_transport.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/SoamJaws/wErld/.eunit/public_transport.erl by COVER 2016-07-05 at 06:54:32

****************************************************************************

        |  -module(public_transport).
        |  -include("public_transport.hrl").
        |  -include_lib("eunit/include/eunit.hrl").
        |  -behaviour(gen_server).
        |  
        |  %% Public API
        |  -export([ start_link/0
        |          , stop/1
        |          , state/1
        |          , ?GET_ROUTE/3]).
        |  
        |  %% gen_server and internally spawned functions
        |  -export([ init/1
        |          , handle_call/3
        |          , handle_cast/2
        |          , handle_info/2
        |          , terminate/2
        |          , code_change/3
        |          , get_route_concurrent/7]).
        |  
        |  
        |  %% Public API
        |  
        |  -spec start_link() -&gt; {ok, pid()} | ignore | {error, {already_started, pid()} | term()}.
        |  start_link() -&gt;
        |    gen_server:start_link(?MODULE, [], []).
        |  
        |  -spec stop(pid()) -&gt; ok.
        |  stop(Pid) -&gt;
        |    gen_server:call(Pid, stop).
        |  
        |  -spec state(pid()) -&gt; public_transport_state().
        |  state(Pid) -&gt;
        |    gen_server:call(Pid, state).
        |  
        |  -spec ?GET_ROUTE(pid(), atom(), atom()) -&gt; {[{pid(), pid(), pid()}], pos_integer()} | none.
        |  ?GET_ROUTE(Pid, FromId, ToId) -&gt;
        |    gen_server:call(Pid, {?GET_ROUTE, FromId, ToId}).
        |  
        |  
        |  %% gen_server
        |  
        |  -spec init([]) -&gt; {ok, public_transport_state()}.
        |  init([]) -&gt;
        |    %% StopIds = [atom()]
        |    %% LineSpecs = [{non_neg_integer(), [atom()], vehicle_type()}]
        |    {ok, {{stops, StopIds}, {lines, LineSpecs}}} = file:script(?PUBLIC_TRANSPORT_DATA_PATH),
        |    StopDict = lists:foldl(fun(StopId, Dict) -&gt;
        |                             {ok, Pid} = supervisor:start_child({global, stop_supervisor}, [StopId]),
        |                             dict:append(StopId, Pid, Dict)
        |                           end , dict:new() , StopIds),
        |    Lines = lists:map(fun({Number, Stops, Type}) -&gt;
        |                        UpdatedStops = lists:map(fun(Element) -&gt;
        |                                                   if
        |                                                     is_integer(Element) -&gt;
        |                                                       Element;
        |                                                     true -&gt;
        |                                                       dict:fetch(Element, StopDict)
        |                                                   end
        |                                                 end, Stops),
        |                        {ok, Line} = supervisor:start_child({global, line_supervisor}, [Number, UpdatedStops, Type]),
        |                        Line
        |                      end, LineSpecs),
        |    {ok, #public_transport_state{lines=Lines, stops=StopDict}}.
        |  
        |  -spec handle_call({?GET_ROUTE, atom(), atom()}, {pid(), any()}, public_transport_state()) -&gt; {reply, {[{pid(), pid(), pid()}], pos_integer()} | none, public_transport_state()}
        |        ;          (stop,                       {pid(), any()}, public_transport_state()) -&gt; {stop, normal, stopped, stop_state()}
        |        ;          (state,                      {pid(), any()}, public_transport_state()) -&gt; {reply, public_transport_state(), public_transport_state()}.
        |  handle_call({?GET_ROUTE, FromId, ToId}, _From, State) -&gt;
        |    Reply = get_route_helper(FromId, ToId, State),
        |    {reply, Reply, State};
        |  
        |  handle_call(state, _From, State) -&gt;
        |    {reply, State, State};
        |  
        |  handle_call(stop, _From, State) -&gt;
        |    {stop, normal, stopped, State}.
        |  
        |  
        |  -spec handle_cast(any(), public_transport_state()) -&gt; {noreply, public_transport_state()}.
        |  handle_cast(_, State) -&gt;
        |    {noreply, State}.
        |  
        |  
        |  -spec handle_info(timeout | any(), public_transport_state()) -&gt; {noreply, public_transport_state()}.
        |  handle_info(_Info, State) -&gt;
        |    {noreply, State}.
        |  
        |  
        |  -spec terminate(normal | shutdown | {shutdown, any()} | any(), stop_state()) -&gt; ok.
        |  terminate(_Reason, _State) -&gt;
        |    ok.
        |  
        |  
        |  -spec code_change(term() | {down, term()}, stop_state(), term()) -&gt; {ok, stop_state()}.
        |  code_change(_OldVsn, State, _Extra) -&gt;
        |    {ok, State}.
        |  
        |  
        |  %% Backend
        |  
        |  %% Instructionsformat: list of tuples {[{Line, Target, Destination}, {Line, Target, Destination}...], Dur}
        |  %% Citizen goes from From to Destination by line in the Target direction, repeat until arrived at To
        |  -spec get_route_helper(atom(), atom(), public_transport_state()) -&gt; {[{pid(), pid(), pid()}], pos_integer()} | none.
        |  get_route_helper(FromId, ToId, State) -&gt;
        |    AllLines = State#public_transport_state.lines,
        |    From = dict:fetch(FromId, State#public_transport_state.stops),
        |    To = dict:fetch(ToId, State#public_transport_state.stops),
        |    ToLines = lists:filter(fun(Line) -&gt; line:?CONTAINS_STOP(Line, To) end, AllLines),
        |    spawn(public_transport, get_route_concurrent, [From, To, ToLines, {[], 0}, [], AllLines, self()]),
        |    receive
        |      {Route, Dur} -&gt;
        |        {compress_route(Route), Dur};
        |      none -&gt;
        |        none
        |    end.
        |  
        |  
        |  -spec get_route_concurrent(pid(), pid(), [pid()], {[{pid(), pid(), pid()}], pos_integer()}, [pid()], [pid()], pid()) -&gt; {[{pid(), pid(), pid()}], pos_integer()} | none.
        |  get_route_concurrent(From, To, ToLines, {Route, Dur}, VisitedStops, AllLines, Invoker) -&gt;
        |    FromLines = [Line || Line &lt;- AllLines, line:?CONTAINS_STOP(Line, From)],
        |    IntersectingLines = get_intersecting_lines(FromLines, ToLines),
        |    case IntersectingLines of
        |      [] -&gt;
        |        Neighbors = lists:append([line:?GET_NEIGHBORS(Line, From) || Line &lt;- FromLines]),
        |        case Neighbors of
        |          [] -&gt;
        |            Invoker ! none;
        |          _ -&gt;
        |            Routes = spawn_get_route_calls(Neighbors, To, ToLines, {Route, Dur}, VisitedStops, AllLines),
        |            {BestRoute, TotalDur} = get_best_route(lists:filter(fun(R) -&gt; R /= none end, Routes)),
        |            Invoker ! {Route ++ BestRoute, Dur + TotalDur}
        |        end;
        |      _  -&gt;
        |        IntersectingLinesWithDurations = [{FromLine, ToLine, IntersectingStop, line:?GET_DURATION(FromLine, From, IntersectingStop) + line:?GET_DURATION(ToLine, IntersectingStop, To)} || {FromLine, ToLine, IntersectingStop} &lt;- IntersectingLines],
        |      {FromLine, ToLine, IntersectingStop, LastDur} = get_best_intersecting_lines(IntersectingLinesWithDurations),
        |      Target = line:?GET_TARGET(FromLine, From, IntersectingStop),
        |      Invoker ! {Route ++ [{FromLine, Target, IntersectingStop}, {ToLine, To}], Dur + LastDur}
        |    end.
        |  
        |  
        |  -spec spawn_get_route_calls([pid()], pid(), [pid()], {[{pid(), pid(), pid()}], pos_integer()}, [pid()], [pid()]) -&gt; [{[{pid(), pid(), pid()}], pos_integer()}].
        |  spawn_get_route_calls(Neighbors, To, ToLines, Route, VisitedStops, AllLines) -&gt;
        |    spawn_get_route_calls(Neighbors, To, ToLines, Route, VisitedStops, AllLines, 0).
        |  
        |  -spec spawn_get_route_calls([pid()], pid(), [pid()], {[{pid(), pid(), pid()}], pos_integer()}, [pid()], [pid()], non_neg_integer()) -&gt; [{[{pid(), pid(), pid()}], pos_integer()}].
        |  spawn_get_route_calls([], _To, _ToLines, _Route, _VisitedStops, _AllLines, NoCalls) -&gt;
        |    receive_routes(NoCalls);
        |  spawn_get_route_calls([Neighbor|Neighbors], To, ToLines, {Route, TotalDur}, VisitedStops, AllLines, NoCalls) -&gt;
        |    VisitedNeighbor = lists:member(Neighbor, VisitedStops),
        |    if
        |      not VisitedNeighbor -&gt;
        |        {From, Dur, Target, Line} = Neighbor,
        |        spawn(?MODULE, get_route_concurrent, [From, To, ToLines, {Route ++ [{Line, Target, From}], TotalDur + Dur}, [From|VisitedStops], AllLines, self()]),
        |        spawn_get_route_calls(Neighbors, To, ToLines, {Route, TotalDur}, VisitedStops, AllLines, NoCalls + 1);
        |      true -&gt;
        |        spawn_get_route_calls(Neighbors, To, ToLines, {Route, TotalDur}, VisitedStops, AllLines, NoCalls)
        |    end.
        |  
        |  -spec receive_routes(non_neg_integer()) -&gt; [{[{pid(), pid(), pid()}], pos_integer()}].
        |  receive_routes(NoCalls) -&gt;
        |    receive_routes(NoCalls, []).
        |  
        |  -spec receive_routes(non_neg_integer(), [{[{pid(), pid(), pid()}], pos_integer()}]) -&gt; [{[{pid(), pid(), pid()}], pos_integer()}].
        |  receive_routes(0, Routes) -&gt; Routes;
        |  receive_routes(NoCalls, Routes) -&gt;
        |    receive
        |      none -&gt;
        |        receive_routes(NoCalls-1, Routes);
        |      Route -&gt;
        |        receive_routes(NoCalls-1, [Route|Routes])
        |    end.
        |  
        |  -spec get_best_route([{[{pid(), pid(), pid()}], pos_integer()}]) -&gt; {[{pid(), pid(), pid()}], pos_integer()}.
        |  get_best_route([Route|Routes]) -&gt;
        |    get_best_route(Routes, Route).
        |  
        |  -spec get_best_route([{[{pid(), pid(), pid()}], pos_integer()}], {[{pid(), pid(), pid()}], pos_integer()}) -&gt; {[{pid(), pid(), pid()}], pos_integer()}.
        |  get_best_route([], BestRoute) -&gt; BestRoute;
        |  get_best_route([{Route, Dur}|Routes], {BestRoute, BestDur}) -&gt;
        |    if
        |      Dur &lt; BestDur -&gt;
        |        get_best_route(Routes, {Route, Dur});
        |      true -&gt;
        |        get_best_route(Routes, {BestRoute, BestDur})
        |    end.
        |  
        |  
        |  %% [{FromLine, ToLine, IntersectingStop}]
        |  -spec get_intersecting_lines([pid()], [pid()]) -&gt; [{pid(), pid(), pid()}].
        |  get_intersecting_lines(FromLines, ToLines) -&gt;
        |    get_intersecting_lines([{FromLine, ToLine, line:?GET_INTERSECTION(FromLine, ToLine)} || FromLine &lt;- FromLines, ToLine &lt;- ToLines]).
        |  
        |  -spec get_intersecting_lines([{pid(), pid(), pid()}]) -&gt; [{pid(), pid(), pid()}].
        |  get_intersecting_lines([]) -&gt; [];
        |  get_intersecting_lines([{_,_,none}|IntersectingLines]) -&gt;
        |    get_intersecting_lines(IntersectingLines);
        |  get_intersecting_lines([IntersectingLine|IntersectingLines]) -&gt;
        |    [IntersectingLine|get_intersecting_lines(IntersectingLines)].
        |  
        |  
        |  -spec get_best_intersecting_lines([{pid(), pid(), pid(), pos_integer()}]) -&gt; {pid(), pid(), pid(), pos_integer()}.
        |  get_best_intersecting_lines([IntersectingLineWithDuration|IntersectingLinesWithDurations]) -&gt;
        |    get_best_intersecting_lines(IntersectingLinesWithDurations, IntersectingLineWithDuration).
        |  
        |  -spec get_best_intersecting_lines([{pid(), pid(), pid(), pos_integer()}], {pid(), pid(), pid(), pos_integer()}) -&gt; {pid(), pid(), pid(), pos_integer()}.
        |  get_best_intersecting_lines([], BestIntersectingLines) -&gt; BestIntersectingLines;
        |  get_best_intersecting_lines([{FromLine, ToLine, IntersectingStop, Dur}|IntersectingLinesWithDurations], {BestFromLine, BestToLine, BestIntersectingStop, BestDur}) -&gt;
        |    if
        |      Dur &lt; BestDur -&gt;
        |        get_best_intersecting_lines(IntersectingLinesWithDurations, {FromLine, ToLine, IntersectingStop, Dur});
        |      true -&gt;
        |        get_best_intersecting_lines(IntersectingLinesWithDurations, {BestFromLine, BestToLine, BestIntersectingStop, BestDur})
        |    end.
        |  
        |  
        |  -spec compress_route([{pid(), pid(), pid()}]) -&gt; [{pid(), pid(), pid()}].
        |  compress_route([Stop|Stops]) -&gt;
        |    compress_route(Stops, [Stop]).
        |  
        |  -spec compress_route([{pid(), pid(), pid()}], [{pid(), pid(), pid()}]) -&gt; [{pid(), pid(), pid()}].
        |  compress_route([], Route) -&gt; Route;
        |  compress_route([{Line, Target, Destination}|Stops], Route) -&gt;
        |    Last = lists:last(Route),
        |    case Last of
        |      {Line,_} -&gt; compress_route(Stops, lists:droplast(Route) ++ [{Line, Target, Destination}]);
        |      _        -&gt; compress_route(Stops, Route ++ [{Line, Target, Destination}])
        |    end.
</pre>
</body>
</html>
